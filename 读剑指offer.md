读剑指offer(第二版)
---------
### 要读的书
*	effective C++
*	敏捷软件开发——原则、模式与实践

### 面试流程
如果能够实现先测试再编程，也许可以让面试官刮目相看。

使用star模型介绍自己的项目经验（star：Situation（背景）、task（任务）、action（职能）、result（收获）） p6  
介绍项目的时候要着重突出自己的贡献  

对于仅仅是了解的技能（没有动手实践过），不同的公司应该侧重不同；熟悉程度以上的技能一般要全写进简历中。尽量少用精通的字眼，否则适得其反。

每一轮面试都有三个环节：面试环节（经验、技能）、技术面（重头戏）、提问环节；
#### 对于跳槽
不要对面试官抱怨：老板苛刻、同时难相处、加班频繁、工资低等。

可以说干的时间太长，没有太多激情，想找一份更有挑战性的工作。我的上份工作已经极大锻炼了我的某项技能，我需要其他方面技能的培养。

#### 基本功
*	扎实的基础知识
	*	编程语言
	*	数据结构（**链表**、**树**、栈、队列、哈希表）可以参考其他数据最近实现一下
	*	算法（查找、排序，重点掌握二分查找、归并与快速排序；动态规划、贪婪算法等）
*	高质量的代码。面试官除了希望应聘者能够完成基本的功能外，还会关注应聘者是否考虑了**边界条件、特殊输入和错误处理（当程序无法处理某些情况发生时，如何处理）**。解决这个办法最好的办法是在写程序之前先想好**测试用例**。
	*	用C完成字符串到整数的转换。需要考虑的问题有很多，例如正负号、字符串指针为NULL、非数字符号、字符串无法转化为整数时应该如何处理等。
	*	如何使用两个指针快速的找到链表倒数第K个元素，一般而言，需要考虑：边界条件，例如K大于链表长度，k为0，链表为空等异常。
*	清晰的思路
	
	> 遇到复杂的问题有三种具体的分析方法：画图能使抽象的问题形象化、举例使抽象问题具体化、分解能使复杂问题简单化。
*	优化时空效率的能力
	*	如果分析递归实现的斐波那契数列算法，可以发现其效率很低，因为有很多重复的工作。
*	优秀的综合能力（沟通、学习能力、知识迁移能力）
*	要提前准备好提问时要问的
*	（网上搜集公司与职位的资料，公司成立时间、主要业务、职位要求等），最好要有明确的职位需要。不要问与自己职位相差太远的问题，例如公司未来5年的战略。不要在技术面的时候问薪水，这个问题应该问HR。因为面试有好几轮，只有所有的都过了才可能被聘。最好问与职位相关的问题。设身处地的想一想，如果你成为了这个团队的一员，你会遇到哪些问题，你想知道什么？问题最好与职位或项目相关。

### 基础知识
***面向对象的特征、构造函数、析构函数、动态绑定、设计模式、UML等等***

算法和数据结构，应该重点掌握二分查找、归并排序和快速排序，做到能随时正确、完整的写出这些代码。

*	一些数据结构
	*	完全二叉树：只有最下面的两层结点度小于2，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树；
	*	满二叉树：除了叶结点外每一个结点都有左右子叶且叶结点都处在最底层的二叉树,。
	*	堆：堆（也叫优先队列），我们可以将堆看做是一棵完全二叉树，它的特点是父节点的值大于（小于）两个子节点的值（分别称为大顶堆和小顶堆）。使用数组来保存堆（堆的宽度优先遍历），可以快速的获取某一个元素的父和子元素（以节点i为例，i的父节点为int((i)/2)；对应的左右子节点为`2*i+1`和`2*i+2`）。    
		*	在堆中，数组的长度并不代表合法的堆中元素的个数，最小数组下标0所代表的元素不属于堆。

*	查找的一般方法：顺序查找、二分查找、哈希表查找、二叉排序树查找
*	熟悉常见的排序方式[参考][1]（常见查找的时间复杂度）
	*	插入排序（稳定排序）
	*	折半插入排序（利用折半查找来加速查找已序部分的插入点）
	*	**希尔排序**（不稳定排序）（所有排序操作都可以从希尔排序开始，后期再优化）
	*	选择排序（不稳定排序）每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。
	*	快速排序，支点不一定位于数组的中间，递归时子数组的长度也不一定一样。[参考][2]
	*	归并排序，分治法的应用。核心思想是有序序列的合并速度比无序序列的合并要快。
*	常见排序算法的时间与空间复杂度       
	<img src="images/sort_attrs.jpg" style="width:600">   

*	代码的完整性
	*	功能测试
	*	边界测试：数据结构的边界、状态转换的边界、功能界限的边界
	*	负面测试：系统是否不执行它不应该完成的操作；

*	错误处理的三种方式
	*	返回一个标志错误的代码，0表示调用成功
	*	设置一个全局变量，类似于C的erron
	*	抛出异常

*	其他
	*	移位：
		*	整数左移补零
		*	整数右移：有符号的补符号位；无符号的补零； 



#### 经典问题汇总
*	写一个将字符串转化为整数的函数我们需要考虑哪些东西？
	*	输入异常
		*	字符串为空
		*	如何使用指针填充整数，也要考虑这个整数地址非法的情况
	*	输入内容异常
		*	输入中包含非数字符号
	*	含正负号的问题
	*	最大整数与最小整数溢出的问题
*	sizeof问题
	*	定义一个空类型，对其求sizeof，值是多少？  1
	*	如果定义了构造与析构函数呢？  1
	*	如果把析构定义为虚函数呢？  4或8 ； 上面的1就不用再加了
	> 在32位系统中是4，在64位系统中是8；因为有虚函数表所以不需要额外的一个字节来标记空对象。
*	为什么C++类中的拷贝构造参数必须是引用类型？P23  
*	赋值函数应该注意哪几点？ P25  
	*	自赋值问题
	*	**异常安全**（赋值运算过程中即使出现了异常，也不会对原对象产生影响，现场可恢复）
	*	内存的释放（被赋值对象与原对象中的内存释放）
	*	返回自身引用，便于链式赋值
	*	参数最好是常量引用 
	*	测试用例：自赋值、不同实例之间的赋值、连续赋值

*	C#中的struct和class的区别是什么？ P28
	
	> C#中struct和class唯一的区别是前者定义的是值类型，后者是引用类型；前者在栈中创建，后者在堆中创建。（而C++中唯一的区别是二者的成员访问权限）
*	在单例模式中遇到的问题：
	*	多线程“**竞速**”问题（race condition）
		*	加锁。如果每次都枷锁，则效率低；可以使用两次if，在加锁之前使用if判断一次。P33
		*	主动调用返回引用的静态成员函数，即再所有线程启动前创建这个对象。
				
				if(instance == null){//没有创建才需要创建
					lock(mutex);//即使到达这里，instance也可能已经被其他线程创建过了，所以要再判断
					if(instance == null)
						instance = new singleton();
					release(mutex);
				}
		*	第一种方法可以按需创建，第二种方法就不是了（有个小小的开销）
*	面试题3 二维数组的查找 p44
	*	基本的思想是尽快的剔除不符合要求的数据。
*	面试题4 替换空格
	*	从尾部开始复制有时候是更好的选择。
	> 为了节省内存在C/C++中**常量字符串**一般放到一个单独的内存区域，当几个指针赋值给相同的常量字符串时，它们会指向相同的内存地址。
	*	两种思想，其中一种是创建一个新的字符串，从前向后扫描旧字符串并写进新字符串；再则就是直接在原字符串上操作，前提是原字符串后有足够的空间。
	*	如何在原字符串上以O(n)时间复杂度完成操作(是否可以在原字符串上操作需要询问面试官)？
		
			void replaceSpace(char *str,int length) {
		        if(str == nullptr)return;
		        int space_count = 0;
				//在这里使用strlen效率不高，
                //因为为了找空格我们必须遍历字符串，所以将字符串长度求解放在遍历空格的过程中更好
		        int str_len = strlen(str);
		        if(str_len == 0)return;
		        
				for(int i=0;i<str_len;i++){
		            if(str[i]==' ')space_count++;
		        }
		        int new_str_len =str_len+space_count*2;
		        str[new_str_len] = '\0'; // 注意字符串的结尾 '\0'
				//如果这里用 `int i = str_len;i>=0;i--` 则不用使用上面那句添加str的结尾'\0'
		        for(int i = str_len-1;i>=0;i--){ 
		            if(str[i] == ' '){
		                str[--new_str_len] = '0';
		                str[--new_str_len] = '2';
		                str[--new_str_len] = '%';
		            }
		            else str[--new_str_len] = str[i];
		        }
			}
*	面试题5 逆序打印单向链表
	*	既然能想到用递归的算法，那么就可以使用栈。
*	面试题6 重建二叉树 [leetcode 105][3]（何为堆、最大最小堆、红黑树？熟悉二叉树的3种遍历的六种实现方法）
	*	会写树的几种遍历方式：先序、中序、后序、宽度优先
*	面试题7 使用两个栈模拟队列、使用两个队列模拟栈
	
	> 这类题目首先要做的是在脑子里模拟一遍流程，对于使用两个栈模拟一个队列，其中一个栈用于“入队”，一个用于“出队”。
*	面试题8 旋转数组的最小值
	*	因为数组是有规律的故可以使用二分法查找，注意几种特殊情况：完全有序则直接返回；无法判断最小值位置只能遍历；
*	面试题9 斐波那契数列
	
	> 有时候递归的效率很低，因为有很多计算都重复了（分析方法就是举例与画图，结果会很明显）如果使用递归来实现斐波那契，效率会很低。所以一般使用循环的方式。   
	*	青蛙跳台问题。举个简单的例子发现结果是棵树，树可以使用递归思想，随后又发现——斐波那契，（把跳法转化为台阶个数n的函数）；
	*	对于那种方法有限求解可能步骤的问题，都可以转化为递归问题。例如填方块问题......
*	面试题10 二进制中1的个数
	*	三种解题思路：
		*	原数右移与1按位与，求结果是否为0，但问题是如果原数是负数就会陷入死循环
		*	1左移与原数进行按位与，但效率不高，无论有多少个一都要运算固定次
		*	**原数减一的结果与原数按位与将消除原数右侧的一个1，举个简单的例子就可以找到规律**。利用这个规律，有多少个1就循环多少次，效率较高。
*	面试题11 数值的整数次方
	*	浮点数的相等因为精度的原因一般不能直接使用`==`，最好使用`fabs(x-y)<DLE_EPSLION`来判断。（`#include<float.h>`)
	*	如果指数是正整数，那么如何使用快速的计算方法？
	*	**使用 `x & 0x1 == 1`来判断x的奇偶性**
	*	无符号整数左移与右移可以快速的计算乘2与除2
*	面试题12 打印1到最大的n位数
	*	这是一个“大数”问题，n比较大时不能使用內建类型，只能使用字符串表示大数
	*	判读结束的方法也有技巧，例如直接使用字符串比较或者直接考虑进位，**使用进位会更快**
*	面试题13 以O(1)时间复杂度删除单向链表中指定的元素
	*	一般的思想是将当前元素的后一个元素复制到当前元素并删除下一个元素（或者将当前元素与下一个元素交换并删除下一个元素）
	*	测试用用例。功能测试：一般的情况，特殊的情况如链表只有一个元素，要删除的元素在链表结尾。
	*	负面测试，如果要删除的元素不在链表中怎么办，一般这种问题可以直接问考官。
*	面试题14 调整数组顺序，使得奇数位于偶数前
	*	因为是前后的问题，所以可以使用两个指针分别指向数组的第一个和最后一个元素，分别向后向前移动，直到两指针相遇。
	*	未来使程序有一定的扩展性，一般可以将判断奇偶的部分抽象出来。
	*	使用两个相对移动的指针一般不要使用相等来结束循环（最好使用小于），否则指针很可能永远都不会相等。
	
			bool is_even(int x){return (x & 1) == 0;}
			//下面的代码是错误的，因为按位与比关系运算优先级低，故将永远返回false
			//bool is_even(int x){return x & 1 == 0;}
			//在牛客网上有更多的约束（类似于稳定排序的要求），所以下面是比较简单的解法，但不高效
		    void reOrderArray(vector<int> &array) {
		        vector<int> even;
		        vector<int> odd;
		        for(auto x:array){
		            if(is_even(x))even.push_back(x);
		            else odd.push_back(x);
		        }
		        
		        array = odd;
		        array.insert(array.end(),even.begin(),even.end());
		    }
	
*	面试题15 链表中倒数第K个节点的值（类似的题目：链表中间的元素、链表是否是循环链表）
	*	这道题主要考察的是代码的健壮性：边界条件、异常输入
	*	常用的技巧是使用两个指针来处理链表
*	面试题16 反转链表
	*	使用三个指针实现链表的反转
*	面试题17 合并两个排序的链表
	*	这个题目可以使用递归完成（有些判断没必要写四次，两次就够了）
*	面试题18 树的子结构
	*	使用递归的解法，注意特殊输入的处理
*	面试题19 二叉树的镜像
*	面试题20 顺时针打印矩阵（画图使问题形象化）
*	面试题21 包含min函数的栈
*	面试题22 栈的压入弹出序列
*	面试题23 从上到下打印二叉树
*	二叉搜索树的后序遍历序列

	> 首先要明确二叉搜索树和树的后序遍历的特点 
*	二叉树中和为某一值的路径

*	面试题29 数组中出现次数超过一半的数字
	*	第一种解法是先排序，位于中间的数字即为所求，使用类似于快排的思想来完成这个任务。
	*	第二种解法是使用两个变量，其中一个保存次数，另一个保存数值。
*	面试题30 最小的K个数
	*	第一种解法依旧是使用快排中的Partition函数
	*	创建一个只保存K个数据的树，每当数据大于K时就从树中删除最大的数；在插入前比较可能比较高效。
*	面试题31 连续子数组的最大和
	*	两种解法，其中一种是分析规律，另一种是使用动态规划。
*	面试题32 从1到n整数中1出现的次数
*	面试题33 把数组排成最小的数
##### 使用空间换取时间
*	面试题34 丑数
	*	使用空间换取时间时
*	面试题35 第一个只出现一次的字符
	*	自行构造一个简单的哈希表
*	面试题36 数组中的逆序对
*	面试题37 两个链表的第一个公共结点
	*	两种解法，时间复杂度相同但空间复杂度不同。
*	面试题38 数字在排序数组中出现的次数
	*	既然是排序数组，首先想到的应该是二叉查找，但在这个问题中二叉查找和顺序查找没有优势。
	*	将二叉查找改进一下，使用二叉查找分别查找第一个出现的地方和最后出现的地方，就可以用一个减法求长度。
*	面试题29 二叉树的深度
	*	看到树首先想到的应该是递归，求深度不是个难题
	*	判断一棵树是否是平衡二叉树（任意节点左右子树深度相差不超过1），如果使用上面提出的求深度的方法，则会重复遍历，浪费时间。

[1]:http://www.cnblogs.com/xkfz007/archive/2012/07/01/2572017.html
[2]:http://developer.51cto.com/art/201403/430986.htm
[3]:https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/