常见算法思想
==========
### 一、动态规划
动态规划的两个核心是状态与状态转移方程，在使用动态规划求解问题的时候我们需要一个初始状态，这个状态可以在求解之前用其他方法先准备好。



### 常见排序算法【[参考][1]】
*	排序算法的概念
	*	内（外）部排序：内部排序指的是数据记录在内存中排序
	*	稳定排序：相同大小的原始其顺序与原始顺序相同

#### ***堆排序***

#### ***快速排序***（分治思想）
快速排序（Quicksort）是对冒泡排序的一种改进。

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

快速排序中核心为`int partition(begin,end)`函数，将`[begin,end]`中的原始分为两段，并返回分段节点的下标。

#### ***归并排序***
分治法的应用。核心思想是有序序列的合并速度比无序序列的合并要快。

	if (first < last)  
	{  
	    int mid = (first + last) / 2;  
	    mergesort(a, first, mid, temp);    //左边有序  
	    mergesort(a, mid + 1, last, temp); //右边有序  
	    mergearray(a, first, mid, last, temp); //再将二个有序数列合并  
	}  

#### ***桶排序/基数排序***

#### 插入排序
插入排序和整理扑克牌很类似。插入排序是稳定的，因为当遇见相等的元素时当前元素会放在相等元素的后面。

改进：折半插入排序

#### 希尔排序
希尔排序又叫**缩小增量排序**。先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

#### 选择排序
每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。

#### 冒泡排序（交换排序）
在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。

冒泡排序与选择排序最大的区别在于比较原始与当前元素的位置，前者为临近元素，后者在一次排序中是固定的。

#### 常见排序算法对比 
<img src="images/sort_attrs.jpg" style="width:600">


[1]:http://blog.csdn.net/hguisu/article/details/7776068/