部份摘自：http://www.jb51.net/tools/zhengze.html#mission

在vim中使用正则表达式的注意：/*{{{*/
	vim毕竟是个编辑器，正则表达式中包含的大量元字符如果原封不动地引用（像perl那样）， 势必会给不懂正则表达式的人造成麻烦，比如 /foo(1) 命令， 大多数人都用它来查找foo(1)这个字符串， 但如果按照正则表达式来解释，被查找的对象就成了 foo1 了。
	于是，vim就规定，正则表达式的元字符必须用反斜杠进行转义才行， 如上面的例子，如果确实要用正则表达式，就应当写成 /foo\(1\) 。 但是，像 . * 这种极其常用的元字符，都加上反斜杠就太麻烦了。 而且，众口难调，有些人喜欢用正则表达式，有些人不喜欢用……
	为了解决这个问题，vim设置了 magic 这个东西。简单地说，magic就是设置哪些元字符要加反斜杠哪些不用加的。
	简单来说：
	\m：除了 $ . * ^ 之外其他元字符都要加反斜杠。一般而言在vimrc中设置set magic，与这个选项是相同的。
	\M：除了 $ ^ 之外其他元字符都要加反斜杠。一般而言在vimrc中设置set nomagic 
	这个设置也可以在正则表达式中通过 \m \M 开关临时切换。 \m 后面的正则表达式会按照 magic 处理，\M 后面的正则表达式按照 nomagic 处理， 而忽略实际的magic设置。
例如：/\m.* # 查找任意字符串 /\M.* # 查找字符串 .* （点号后面跟个星号）
	另外还有更强大的 \v 和 \V。
\v （即 very magic 之意）：任何元字符都不用加反斜杠
\V （即 very nomagic 之意）：任何元字符都必须加反斜杠
例如：
	/\v(a.c){3}$   # 查找行尾的abcaccadc /\m(a.c){3}$   # 查找行尾的(abc){3} /\M(a.c){3}$   # 查找行尾的(a.c){3} /\V(a.c){3}$   # 查找任意位置的(a.c){3}$

本文下面使用的元字符都是 magic 模式下的。
如果只输入 he 系统会自动匹配处于任何位值的HE、hE、he、He。为了匹配 he 这个单词，应该使用 \bhe\b 这样的语法。/*}}}*/

正则表达式常见符号：/*{{{*/ 2015-08-07 08:16:40
	\b		 用于匹配一个位置，表示单词的开始和结束。
	\B		 非单词的开始与结尾。
	.		 用于匹配除换行符之外的所有字符。
	*		 重复0次或更多次。*重复其前面的元，例如/ab*  *仅表示b的个数是0或1或2或3....inf。如果想重复ab：(ab)*
	+		 和*的区别在于+表示最少一个符号，而*表示可以是零个符号。重复1次或更多次。
	?		 重复0次或1次。
	\w		 用于匹配非空格符。
	\W		 表示非非空字符。
	^		 匹配字符串的起始位值。
	$		 用于匹配字符串的结尾。
	[]		 表示一个范围，例如[abcd]表示只匹配abcd这四个字符，而[0-9]就和\d是一个意思。
	[^x]	 匹配非x的所有字符。
	[^abcd]	 匹配非abcd的字母。
	{m}		 其中m是数字，例如{2}。这表示{m}前面的操作匹配n次，例如：\d{3}表示有三个连续的数字。
	{m,}	 重复的次数不小于m
	{m,n}	 表示其前面匹配符的匹配次数不能小于m，也不能大于n。
	()		 表示子表达式，这样结合{}就可以重复多个字符。例如：(\d{1,3}\.){3}\d{1,3}
	\		 类似于C这个字符表示转义。
	|		 条件分枝符，位于 | 左右是相互独立匹配规则。类似于的或，只要左侧的规则被匹配，右侧的规则就不会被使用。
	\=		 表示其前方的数据可有可无。/folders\= 匹配 folders or folder
	[^"]	  any character that is not a double quote
	/*}}}*/
	\d	digit			[0-9]
	\D	non-digit		[^0-9]
	\x	hex digit		[0-9a-fA-F]
	\X	non-hex digit		[^0-9a-fA-F]
	\s	white space		[ 	]     (<Tab> and <Space>)
	\S	non-white characters	[^ 	]     (not <Tab> and <Space>)
	\l	lowercase alpha		[a-z]
	\L	non-lowercase alpha	[^a-z]
	\u	uppercase alpha		[A-Z]
	\U	non-uppercase alpha	[^A-Z]


引用和零宽断言：/*{{{*/
后向引用：
	每一个圆括号表示一个子表达式（也称之为分组），而每一个子表达式有一个组号，从左到右分别编号为1,2,3...而0表示整个表达式。
	例如：\b(\w+)\b\s+\1\b 表示先匹配一个单词，而这个单词会被纪录到组号1中，后面的\1表示匹配组号1中的单词。
那么这行语句可以匹配重复的单词，例如：go go，hello hello...
	当然了，组号只是一个标记，而这个标记可以人为的给出：(?<word>\w)或(?'word'\w)这时这个组的名字就是word。

零宽断言：（零宽带表示某些规则不会出现在匹配出的串中，这些规则出现在匹配串的前后。）
	(?=exp)：零宽度正预测先行断言。需要匹配的串的后面要满足表达式exp。例如：\b\w+(?=ing\b)使用在i am singing while you are dancing时，会匹配出sing和danc。
	(?<=exp):零宽度正回顾后发断言。需要匹配的串的前面要满足exp表达式。例如：(?<=\bre)\w\b使用在reading a book时会匹配出ading。
负向零宽断言：
	\b\w*q[^u]\w*\b是无法匹配出Iraq和Benq这样的单词的，因为[^u]在匹配时需要占用一个宽度。
	负向零宽断言和正向零宽断言的区别是正向零宽断言表示匹配串的前后应有什么，而负向零宽断言则表示匹配串中不应该有什么。
	\b\w*q(?!u)\w*\b就是利用了零宽断言不占宽度的性质。在这里使用的是先行断言，也就是说(?!u)是和q相结合的。
	\b\w*(?<!u)q\w*\b是后发断言，此时(?<!u)是和q结合，说明q之前面的字母不能是u。
主意先行和后发的意义：
	先行与后发与其位置有关，相同的位置不同的先行与后发会和不同的字符相匹配。

		分类		代码/语法	    说明
		捕获		(exp)	        匹配exp,并捕获文本到自动命名的组里
					(?<name>exp)	匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
					(?:exp)     	匹配exp,不捕获匹配的文本，也不给此分组分配组号
		零宽断言	(?=exp)     	匹配exp前面的位置
					(?<=exp)	    匹配exp后面的位置
					(?!exp)     	匹配后面跟的不是exp的位置
					(?<!exp)    	匹配前面不是exp的位置
		注释		(?#comment) 	这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读
/*}}}*/

贪婪和懒惰:/*{{{*/
	当正则表达式中包含能接受重复的限定符例如：*、+、?等时通常系统会匹配尽可能长的串。例如a.*b用在aabab时匹配出：aabab。这种匹配方式称为贪婪模式。
	为了匹配出aab，此时使用懒惰模式，即在可重复的限定符后加上?，例如：a.*?b用在aabab上时匹配出：aab，也可以在{,}中添加负号表示尽可能少的匹配。
	表5.懒惰限定符
		代码/语法	说明
		*?			重复任意次，但尽可能少重复
		+?			重复1次或更多次，但尽可能少重复
		??			重复0次或1次，但尽可能少重复
		{n,m}?		重复n到m次，但尽可能少重复
		{-n,m}		重复n到m次，但尽可能少重复×××××××××××××××××××××××
		{-}			重复尽可能的少。×××××××××××××××××××××××××××××××××
		{n,}?		重复n次以上，但尽可能少重复
/*}}}*/

表6.尚未详细讨论的语法/*{{{*/
		代码/语法		说明
		\a				报警字符(打印它的效果是电脑嘀一声)
		\b				通常是单词分界位置，但如果在字符类里使用代表退格
		\t				制表符，Tab
		\r				回车
		\v				竖向制表符
		\f				换页符
		\n				换行符
		\e				Escape
		\0nn			ASCII代码中八进制代码为nn的字符
		\xnn			ASCII代码中十六进制代码为nn的字符
		\unnnn			Unicode代码中十六进制代码为nnnn的字符
		\cN				ASCII控制字符。比如\cC代表Ctrl+C
		\A				字符串开头(类似^，但不受处理多行选项的影响)
		\Z				字符串结尾或行尾(不受处理多行选项的影响)
		\z				字符串结尾(类似$，但不受处理多行选项的影响)
		\G				当前搜索的开头
		\p{name}		Unicode中命名为name的字符类，例如\p{IsGreek}
		(?>exp)			贪婪子表达式
		(?<x>-<y>exp)	平衡组
		(?im-nsx:exp)	在子表达式exp中改变处理选项
		(?im-nsx)		为表达式后面的部分改变处理选项
		(?(exp)yes|no)	把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no
		(?(exp)yes)		同上，只是使用空表达式作为no
		(?(name)yes|no)	如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no
		(?(name)yes)	同上，只是使用空表达式作为no/*}}}*/
