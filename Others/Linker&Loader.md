-	目标文件和可执行文件的格式十分相似，动态链接库和静态链接库的内容也和可执行文件十分相似。对于动态链接和静态链接库Wndows下分别为.dll和.lib文件，而在linux下为.so文件和.a文件。

-	对于可执行文件或者目标文件，他们都有文件头（包含在文件靠前的位值，描述这个目标文件的性质）。文件头描述这个文件是可执行文件还是可链接文件或者是一个库文件。

-	可执行文件分段的理由： 
	 1. 保护代码段。 
	 2. 因为CPU的cache有限，减小缓存的大小可以增加命中率。 
	 3. 可以共享代码段。 

-	目标文件内主要有两种数据：代码和数据。 
> ELF头部		| 	本文件的信息	 
> 段头部表	|	用来描述各个段的信息，如段的名称和段的位置和偏移量
> .init		| 	 
> .text		|	代码段	 
> .rodata		|	只读数据区
> .data		|	数据段	全局变量和局部静态变量
> .bss		|	不占空间
> .symtab		|	符号表	 
> .debug		|	调试信息	 
> .line		|		 
> .strtab		|	字符串表	 

-	未初始化的全局变量和局部静态变量默认值为0
-	可执行文件中可以有自定义段，例如可以使用工具objcopy将二进制文件（一张图片）写入可执行文件中。

-	符号：函数和变量被称为符号。函数名和变量的名称称为符号名。

-	在代码文件中，因为处于不同作用域的函数和变量可以同名若不对这些名称进行更改在连接时会产生冲突，故编译器会对符号进行修饰。GCC和VS对符号的修饰规则是不同的，故使用不同编译器编译出的库在不经过特殊处理的情况下是不能通用的。这也解释了使用微软编译器编译出的FLTK库不能被GCC编译器直接使用，因为符号的修饰方法不同故GCC编译器在连接时无法在VS编译出的库中找到对应的符号。

-	符号表：目标文件中有一个段保存着程序中的符号。这个段是一个数组，其中的数组元素是结构体。在每一个结构体中都保存着对应符号的名称和性质。例如表示一个符号是否在本单元定义。

-	因为在对C和C++进行编译时编译器对符号的修饰方法是不同的，故即使在C++中调用C编译器编译出的库中的 函数有时也无法直接调。此时需要在C++中表明某些函数时C 函数，不需要使用C++的名字修：extern "C" {int func();}  


