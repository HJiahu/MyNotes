-	在类内，编译器扫描所有声明之后再进行编译，故变量的使用与声明的次序并不重要，但在其他地方无论函数还是变量，都要先声明再使用。
-	C++中只能使用引用与指针实现多态的原因：
	-	从底层执行过程来讲：对象赋值的过程中vptr是不会改变的，即赋值是无法实现多态的。
	-	注意里氏替换原则的最通俗的解释：[子类可以扩展父类但子类不能改变父类的功能](http://52347.iteye.com/blog/1860477)。
	-	从内存分布的角度来讲，子类的成员很可能多余父类，如果在赋值的过程中将父类的vptr改为子类的vptr，则在程序运行的过程中，子类的虚函数在运行的过程中很可能会访问那些并不存在于父类中的成员，此时必然出错。
	-	类的初始化与赋值都有对应的函数，分别为构造函数和拷贝构造函数，而这些函数只能处理左面对象中定义的变量，若用于初始化或给左边对象赋值的对象是左边对象的子类，则这些函数也只能处理父类中的参数，子类中的成员将会被抛弃，这是切片问题。
	-	纯虚函数存在的一个重要意义就是避免对象切片的问题（纯虚函数的存在禁止了类的实例化，也就避免了父类对子类的切片）。
	-	对象的类型是确定不变的，故我们无法使对象的动态类型与静态类型不同（对于指针与引用而言，真正的对象在内存中而不是定义的指针或引用的类型）。

-	类中自赋值的处理一定要小心。
-	shared_ptr在执行非单个元素时需要为其提供额外的删除器。
