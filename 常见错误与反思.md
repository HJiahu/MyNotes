-	在类内，编译器扫描所有声明之后再进行编译，故变量的使用与声明的次序并不重要，但在其他地方无论函数还是变量，都要先声明再使用。
-	C++中只能使用引用与指针实现多态的原因：
	-	从底层执行过程来讲：对象赋值的过程中vptr是不会改变的，即赋值是无法实现多态的。
	-	注意里氏替换原则的最通俗的解释：[子类可以扩展父类但子类不能改变父类的功能](http://52347.iteye.com/blog/1860477)。
	-	从内存分布的角度来讲，子类的成员很可能多于父类，如果在赋值的过程中将父类的vptr改为子类的vptr，则在程序运行的过程中，子类的虚函数在运行的过程中很可能会访问那些并不存在于父类中的成员，此时必然出错。
	-	类的初始化与赋值都有对应的函数，分别为构造函数和拷贝构造函数，而这些函数只能处理左面对象中定义的变量，若用于初始化或给左边对象赋值的对象是左边对象的子类，则这些函数也只能处理父类中的参数，子类中的成员将会被抛弃，这是切片问题。
	-	纯虚函数存在的一个重要意义就是避免对象切片的问题（纯虚函数的存在禁止了类的实例化，也就避免了父类对子类的切片）。
	-	对象的类型是确定不变的，故我们无法使对象的动态类型与静态类型不同（对于指针与引用而言，真正的对象在内存中而不是定义的指针或引用的类型）。

-	类中自赋值的处理一定要小心。
-	shared_ptr在执行非单个元素时需要为其提供额外的删除器。
-	类只是一种类型。
-	类成员函数一不能作为类内的线程函数（要做特殊的处理），因为在未定义对象前程序无法确定函数的地址（成员函数一般会访问成员变量，然而成员变量只有在定义对象的时候才能确定）。当然了，如果成员函数是static的就可以。
-	如何解决超前引用的问题。
-	一个错误：没有为线程提供完整的参数列表。
-	有些线程对象的生命周期必须是静态的。
-	线程在创建之初就已经启动了，然而使用父类控制线程函数，使用子类实现线程函数是危险的，因为线程可能在父类创建之初就被启动，此时多态已经失效[参考](http://stackoverflow.com/questions/10634603/c11-thread-doesnt-work-with-virtual-member-function)。解决这个问题的一种方式是：将线程的创建独立出来，等确定对象完全创建之后再启动线程[参考](https://rafalcieslak.wordpress.com/2014/05/16/c11-stdthreads-managed-by-a-designated-class/)
-	如果在基类中定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。
-	函数有声明与定义，而类有声明、定义、实现三层。函数的定义与类的实现是同样的意义。
-	我们不能对运算符的求值顺序做任何的假设：
```
//下面的代码在使用arm-linux-gnueabihf-gcc 4.7.3 和 桌面版的gcc 4.8.4版本编译之后执行的结果是不同的，前者为2后者为3。
//使用vs2015编译后执行的结果是2。
char a[2] = {1,2};
char *p = a;
char b = *p++ + *p;//在这里后缀自增的优先级高于结引用运算符，如果先求加号左边的值则b = 3；如果先求加号右边的值则b = 2；这依赖于编译器。
```
-    C++多线程中join与detach最直观的区别就是：在函数`a`中调用线程`b`的join之后函数`a`就会阻塞在join语句之处直到b执行完成，而detach不会这样。
-    在C++11中，vector保证保存的内容是连续的，但这个保证的前提是“存储空间相同”：vector在存储空间不足时会重新分配内存空间，此时所有内容依旧是连续的但与重新分配内存之前的内容而言，二者又没有什么关系。
-    因为capacity的变化，vector会重新分配内存从而导致vector的迭代器失效。
-	注意find_first_of的意义，find_first_of与search的区别很是非常明显的。
	-	find_first_of用于查找子串中出现的元素，不用于全子串的匹配。
	-	search可以用于子串的匹配。
-	lambda表达式返回的是一个可执行对象，要想在定义的地方执行lambda表示是，需要在表达式后加括号（参数）表示调用。
-	最好不使用全局变量，使用全局变量时也尽可能的使用指针指向全局变量：extern asio::io_service *io_ptr;(使用asio出现了duplicate sectiond的错误，我当时使用的方式是extern asio::io_service io_service，编译器可能在不同的文件中条件编译service？？？)
-	const 默认只在当前编译单元可见，但其他的变量就不一定了。
-	改变头文件的包含顺序可以解决一些问题，如若FLTK的头文件在asio头文件之前，会出现win32 sock以定义的错误。如果改变二者包含顺序，则可以避免这个错误。
-	asio::steady_timer中没有默认构造函数，所以不能使用map的下标运算符来添加steady_timer实例。
-	使用互斥量的时候不要在获得锁之后执行耗时的操作，例如网络编程中的recv，一般可以这样，先使用recv读取数据并保存在临时变量中，然后再请求锁并将数据从临时变量拷贝进目标对象，再释放锁（绝大部分情况下数据拷贝要远快于recv，recv可能会阻塞）
































