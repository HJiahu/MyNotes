本文摘自：Computer Networking ------a top-down approach
-	目录 <span id="Index"/>
-	[tips](#0)
-	[第一、二章 简介和应用层](#1)
-	[第三章 运输层（第二层）](#2)
-	[第十章 网络层](#3)
-	[在网络上传输的包](#B)
### tips [\[Index\]](#Index) <span id="0"/>      
-	RJ-45网线的连接规则：一般而言当同种设备相连时使用交叉线，异种设备相连使用直通线。在这里，设备只分为两类：DTE（数据终端），DCE（数据通信设备）。如今的网卡有自动识别功能，故一般直通和交叉可以混用。
-	集线器和交换机（第二层交换机）：集线器是无源的，工作原理为CSMA/CD；而交换机有端口MAC记忆功能，其不会发生数据碰撞。

### 第一、二章 简介和应用层  [\[Index\]](#Index) <span id="1"/>       
一些关键字：
-	URL： Uniform Resource Locator
-	viral marketing ：病毒行销，可以自我行销的产品称为病毒行销。邮件就是病毒行销的典型例子。             （先行者优势）
-	分组嗅探器 ：packet sniffer

网络程序有两类：
-	一类为网络应用程序，它们由RFC所定义的标准协议实现。
-	另一类为专用的网络程序。注：开发一个网络应用程序不能使用RFC中已被使用了的周知端口号。                       

网络的分层结构：
-	应用层：
	-	应用层协议：DNS（53）、HTTP（80） 、SMTP（25）、FTP（20  21 ） ... ***应用层协议主要关注的是数据的内容（如数据的格式），和数据的传输没有关系。***
	-	应用层数据：报文（message）
	-	应用层性能：可靠数据传输（可以利用TCP）、吞吐量、定时、安全性（SSL：  secure socket layer）
-	传输层：
	-	传输层协议：TCP（面向链接，三次握手）、UDP（面向报文）   ***从这一层就开始讨论数据的传输问题，进程之间的逻辑链路。***
	-	传输层数据：报文段（segment）
-	网络层：
	-	网络层协议：IP   （***主机之间的逻辑链路，这些主机不一定直接相连***）
	-	网络层数据：数据报（datagram）
-	数据链路层（***两台直接连接的主机之间的通信***）：
	-	数据链路层数据：帧  这个时候主要讲电信号和光信号  不再是比较抽象的东西。
-	物理层：
	-	主要讲硬件，和信号已经没有多少关系。
	-	HFC:Hybrid Fiber－Coaxial：混合光纤同轴电缆网。是一种经济实用的综合数字服务宽带网接入技术 。HFC通常由光纤干线、同轴电缆支线和用户配线网络三部分组成，从有线电视台出来的节目信号先变成光信号在干线上传输；到用户区域后把光信号转换成电信号，经分配器分配后通过同轴电缆送到用户
 
TCP：Transmission Control Protocol 
> 面向连接的，可靠的数据传输。先握手再通信。拥有拥塞控制机制，这对实时数据传输是不利的。故实时应用可选用UDP，但很多防火墙被配置为阻塞UDP流量，故应以不同的情况选取不同的运输层协议。

UDP：User Datagram Protocol
> 面向报文。仅提供最小服务。UDP是无连接的，相对于TCP而言没有握手过程，是不可靠的数据连接。

SSL：（secure socket layer） 
>处于TCP与UDP之上，为TCP与UDP提供加密机制。SSL并未对TCP与UDP产生影响。两个进程之间通信一般需要两个地址，一个为目的主机的IP地址，二是目的进程的端口号。（开发一个新的网络应用程序，必须为其分配一个新的端口号。）

流量强度：
>接收比特的速率和传输比特的速率之比，流量强度不能大于  1 。

***应用层协议HTTP***
-	端口号：80 ＴＣＰ连接           

***web：***
-	web使用应用层协议HTTP（端口号：80，使用的传输层协议为TCP），web由多个对象组成，一般若web包含html文本和5个图片，则这个web有6（1+5）个对象。每个对象通过对应的URL进行引用。
-	HTTP服务器并不保存关于客户机的任何信息，故称HTTP为无状态协议。即使客户端在很短的时间内对同一对象进行请求，服务器也会进行反应。

-	非持久连接：
> web每个对象的请求均建立一个独立的TCP，但这些TCP可并行建立从而加快了响应速度。

-	持久连接：
> 对于同一客户机与服务器之间只建立一条TCP，所有对象由TCP传输。

***cookie***                    
-	虽说HTTP是无状态的，但可以使用cookie使服务器跟踪用户的动作。cookie系统由四个部分组成：
1. HTTP响应报文中有一个cookie首部行。
2. HTTP请求报文中有一个cookie首部行。
3. 用户系统中有一个cookie文件。
4. 在web站点有一个关于cookie的后端数据库。
-	cookie标识码由服务器产生，并用于服务器对端系统的身份识别，web系统可以使用cookie（设识别码为12345）记录用户12345（系统不知道用户的真实姓名）的行为，并通过这些数据对用户做出一些反应，例如对用户推荐一些产品。若将cookie识别码与用户的用户名和密码对应，则用户在下次登录系统是可以不用输入用户名和密码。
-	cookie的一个争议就是使用cookie可能会侵犯用户的隐私。

web缓存器（web cache）也称为web代理器（proxy  server）：
-	web  cache即使客户机也是服务器，当浏览器向web缓存发出请求时，web缓存为服务器，当web缓存向源web服务器请求数据时（缓存中缺少某些对象）其又是客户机。
-	web  cache可以是一台主机由ISP提供，也可以是本PC机上的一个通用的软件。
-	web  cache存在与源web  sever 同步的问题，一般web缓存会在一定的时间里与源web server同步，同步时使用的是条件GET指令。

***FTP***
-	端口号：21  (File Transfer Protocol)
-	FTP与HTTP均是建立在TCP连接上的，但ＦＴＰ存在两类TCP连接，一类为控制连接，一类为数据连接。其中控制连接是持久连接，数据连接是非持久连接。
-	ＦＴＰ被称为带外（out-of-band）传输，因为FTP的控制信号传输由一条单一的TCP传输，与数据传输不是一条TCP。HTTP被称为带内（in-band）传输，虽说HTTP的对象传输使用不同的TCP，但控制信号在每个TCP中传输，即控制信号和数据信号在相同的TCP中传输。
-	FTP在整个会话中会通过控制连接保留用户的状态和行为，而HTTP不会保留用户的状态。

应用层协议SMTP（端口号：25 TCP） Mail      （simple mail transfer protocol ）
应用层协议p2p。

***DNS***（domain name system ）：
-	DNS为应用层协议的原因（关心数据的内容而不是传输的方式）：
	-	使用客户机/服务器的模式在通信的终端运行。
	-	在端系统之间通过下面的端到端运输层协议传送ＤＮＳ报文。
-	ＤＮＳ系统的组成：
	-	一个分层的ＤＮＳ　server 实现的分布式数据库。
	-	一个允许主机查询分布式数据库的应用层协议。
-	DNS服务器通常是运行着BIND（berkeley internet name domain）软件的unix服务器。
-	***ＤＮＳ运行在UDP上，且为其他应用层协议所使用（如HTTP 、FTP、SMTP）。***
-	用浏览器描述ＤＮＳ工作过程：
	-	同一台主机运行着ＤＮＳ应用的客户端。
	-	浏览器将域名传输给ＤＮＳ应用的客户端。
	-	ＤＮＳ客户机端向ＤＮＳ服务器发送一个包含主机名的ＤＮＳ请求。
	-	ＤＮＳ服务器返回一个（或一个集合）对应的主机ＩＰ地址。
	-	ＨＴＴＰ通过返回的ＩＰ与对应主机建立ＴＣＰ连接。
-	ＤＮＳ的其他功能：
	-	主机别名（host aliasing）：主机由唯一的规范主机名（和一个与之对应的ＩＰ集），但可能有多个与之对应的简单的易于记忆的别名，DNS将其转化为规范主机名，从而可以获得对应的IP。
	-	邮件服务器别名。
	-	负载分配：同一域名下可能有不同的主机，位于不同的地理位置，有不同的IP地址。DNS返回IP地址是很多时候返回的是IP集合。DNS可以通过改变IP集合中IP的顺序从而改变不同服务器的负载（因为应用程序一般选择IP集合前面的IP）。
-	DNS系统的实现：
	-	单DNS服务器：
        > 缺点：单点故障。通信容量巨大（traffic volume）远距离集中式数据库。维护困难。              

-	分布式层次数据库结构：
> 第一层：13个DNS根服务器；                  
> 第二层：顶级域名服务器（TLD），如.com  .org  .cn  .xyz                  
> 第三层：DNS服务器/权威dns服务器，如google.com                
> 本地dns服务器一般不属于dns系统，本地dns服务器只是相当于一种缓存。             

-	***权威域名服务器：每一个在internet中的有公共可访问主机的组织或机构，必须提供公共可访问的DNS记录，并将之存放在权威DNS服务器中。*** 权威DNS服务器可以是本组织的服务器也可以租用其他组织的服务器。权威DNS服务器位于DNS系统的底层，可以返回对应主机的IP。
-	权威DNS存在的理由：每一个机构都有很多的主机，这些主机可能位于不同的地理位置，有不同的IP地址，但他们可能有相同的域名，如果这些信息全部由顶级域名服务器进行管理，工作量太大，而且也不便于公司进行维护，存在权威DNS服务器，公司对服务器的分布与管理可以有更多的自由度，只要权威DNS服务器不变，其他服务器可以进行随意的变动，所需要的只是更改权威DNS服务器中的数据。

-	DNS的查询可以使用递归形式和迭代查询：
	-	递归查询：每次查询都使用相同的步骤，但这些步骤是串行的，即只有下一步的操作完成，上一步的操作才能执行。
	-	迭代查询：每次查询都使用相同的步骤，但每次查询之间没有什么联系，某一步的查询是否完成对其他的查询没有影响。
-	DNS记录(resource   record 简称RR)的格式：（name   value   type     TTL ）
-	TTL（time to live ）用于记录本地记录的生存时间，当TTL大于一个值时，记录会被删除。
-	DNS记录的四种形式：
	-	（name      value      A     TTL）：value为主机名name对应的IP
	-	（name      value      NS    TTL）：value为主机name所属的权威DNS服务器的主机名（不是IP地址）。很多机构的权威DNS服务器是租赁的。
	-	（name      value      CNME  TTL）：value为主机别名为name的规范主机名。
	-	（name      value      MX    TTL）：value 为主机别名为name的主机的邮件服务器的规范主机名。
-	相同的别名但当请求不同的DNS记录时会获得不同的DNS记录，可能是主机的规范主机名或邮件服务器的规范主机名。
-	DNS服务只有两种报文，分别为查询报文和回答报文，且二者的报文格式是相同的。回答报文可能有多个，因为同一个域名可能有多个IP。
-	注册一个全新的域名最少要向对应的TLD注入A型与NS型两种记录。
-	如果一台DNS服务器是某个主机的权威DNS服务器其中含有一个A型记录。
-	如果一台DNS服务器不是某个主机的权威DNS服务器，则其中含有两条记录：NS型记录，记录对应主机所属的权威DNS服务器的主机名。A型记录，权威DNS服务器的IP。
-	大部分的DNS洪泛攻击可以由本地DNS缓存缓解。
-	中间人攻击：
> 中间人攻击（Man-in-the-MiddleAttack，简称“MITM攻击”）是一种“间接”的入侵攻击。这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信终端之间，这台计算机就称为“中间人”。



### 第三章 运输层（第二层） [\[Index\]](#Index) <span id="2"/>      
运输层（传输的数据是 运输层报文）：
> 运输层为运行在不同主机上的应用程序提供逻辑通信（网络层提供主机之间的逻辑通信，运输层有软件的端口信息）。运输层是在端系统中实现的，只工作在端系统，不在网络路由器中实现。

运输层的工作方式：
> 运输层扫描获得的运输层报文，从中获取相关信息，不同的运输层报文会被重新定向到不同的进程的套接字，这个过程称为***多路分解***，而反过程称为***多路复用***。一般在运输层报文段中有目的端口号和源端口号。

一般的进程是不能使用周知端口号（0~1023）的，端口号是一个16字节的数据。

***UDP报文结构***          
报文尾部...报文数据 | 校验和 | 长度 | 目的端口号 | 源端口号（报文首部）           

***TCP***        
-	TCP 连接是点对点的，而且是全双工的。
-	TCP的三次握手（这三次都是***特殊的报文段***，前两个报文没有进行数据的传输，只是进行了一些交流）
	-	客户端向服务器发出请求（我想建立一条TCP）
	-	服务器对客户端进行回复（我已经准备好了，或者没准备好）
	-	客户端再次发送一个***特殊的报文***，这个报文可以包含部分的数据。
-	MTU  maximum Transmission unit 

***很多关于运输层的知识与细节问题在这里没有记录。***

#### ***TCP套接字编程***                
套接字编程一定分别存在存在客户端和服务器端进程，在TCP套接字编程中必然要先建立一个TCP链接，那么就需要两种套接字：
-	用来创建新TCP连接的套接字。用于与服务器相连接，服务器一定存在一个监听进程，客户端进程一定要先与监听进程进行通信。
-	创建完成之后的新套接字。与服务器连接之后，由监听进程通知服务器端，再建立一个进程来与客户端交互，监听进程继续监听其他请求。
-	客户端套接字最少需要服务器地址和端口号这两个参数，而服务器端的欢迎套接字一般就只有一个端口号。
-	可以同时使用ip和端口号来区分数据源，即使端口号相同，来自不同主机的数据的ip也是不同的。

***UDP套接字编程***                  
> udp套接字编程和TCP的区别是udp不需要建立tcp通信管道。

***UDP套接字和TCP套接字的一些区别***
> TCP是面向连接的，故其套接字中有四元数据组用来保存目的地IP、目的地端口号、源ip、源端口号，这些数据用来确定数据的来源。            
> UDP是面向报文的，它只是尽最大可能传输数据，故在UDP报文中只使用一个两元的数据组用来区别数据的来源。      
> 从应用的角度，对于tcp而言，只有四元组中的所有数据都匹配，这个报文才会定向到对应的套接字，以确定数据是来自同一个管道。然而UDP不是这样，只要目的端口和目的ip匹配，数据就会被重定向对应的套接字，无论数据的来源ip是否相同。


### 第十章 网络层  [\[Index\]](#Index) <span id="3"/>      
-	在同一个物理网段内，主机的 IP 具有相同的 Net_ID ，并且具有独特的 Host_ID
-   在同一个网段内，Net_ID 是不变的，而 Host_ID 则是不可重复，此外，Host_ID 在二进制的表示法当中，不可同时为 0 也不可同时为 1 ，因为全为 0 表示整个网段的地址 (Network IP)，而全为 1 则表示为广播的地址 (Broadcast IP)。例如上面的例子当中，192.168.0.0 (Host_ID 全部为 0)以及 192.168.0.255 (Host_ID 全部为 1) 不可用来作为网段内主机的 IP 设定，也就是说，这个网段内可用来设定主机的 IP 是由 192.168.0.1 到 192.168.0.254；
- 	在同物理网段的主机如果设定相同的网域 IP 范围 (不可重复)，则这些主机都可以透过 CSMA/CD 的功能直接在区网内用广播进行网络的联机，亦即可以直接网卡对网卡传递数据 (透过 MAC 讯框)；
-	在同一个物理网段之内，如果两部主机设定成不同的 IP 网段，则由于广播地址的不同，导致无法透过广播的方式来进行联机。 此时得要透过路由器 (router) 来进行沟通才能将两个网域连结在一起。
-	特殊的IP地址：
	-	255.255.255.255   广播地址，这种IP数据报会被发送给***子网***中所有的主机。
	-	特殊的 loopback IP 网段：127.0.0.1  主机地址，即使机器没有安装网卡，也可以使用这个地址，其指向的就是当前主机。127.0.0.1又称为1o地址。
	-	0.0.0.0：严格意义上来说，0.0.0.0已经不是真正意义上的ip地址了。它表示的是这样一个集合，所有不清楚的主机和目的网络。这里的不清楚是指在本机的路由表里没有特定条目指明如何到达。对本机来说，它就是一个收容所，所有不认识的三无人员，一律送进去。
-	早在 IPv4 规划的时候就担心 IP 会有不足的情况，而且为了应付某些企业内部的网络设定，于是就有了私有 IP (Private IP) 的产生了。私有 IP 也分别在 A, B, C 三个 Class 当中各保留一段作为私有 IP 网段:
	-	Class A：10.0.0.0    - 10.255.255.255
	-	Class B：172.16.0.0  - 172.31.255.255
	-	Class C：192.168.0.0 - 192.168.255.255
-	子网掩码的意义：人为的设定IP地址的Net_ID和Host_ID的位数，便于网路的人为划分。
-	网络层提供单一的尽力而为的服务。
-	每一台路由器都有一个  ***转发表***  路由的目的在于传递位于不同网段的IP数据报。
-	每一台主机都有其自己的路由表。即使普通的笔记本，其内部也有自己的路由表，当有一个IP数据报需要发送时，当前主机会检测IP数据报的目的地址，如果目的地址和本机处于同一个网段，那么就使用区域网功能将数据发出去。但是当主机发现IP数据报的目的地址与本机不在同一个网段，那么主机就会将IP数据报发向预设路由器（default gatway）上。
-	最长前缀匹配规则：
> 假设有4亿台主机。那么当一台主机向另一台发送消息时，若每一个路由器都维护一个有4亿条记录的转发表，这个量太大了，很难实现。              
> 假设路由器有四个向外转发的接口，每个接口连接在不同的地址空间端，那么拿ip报首地址的前几位与这些端口的段范围进行匹配，将数据用匹配到的端口向外发送。     
> 这种方法叫 ~           

***交换机的一般结构****
-	输入端口：一般在每一个输入端口都有一个处理器，用来搜索转发路径。而转发表一般由中央选路处理器算得。
-	可以使用多种手段来加快查询速度，例如使用快速的查询算法（如二叉树查找）或者保存最近使用的数据（相当于缓存）。

[***IP数据报格式***](#IP_package) 

***IP数据报的分片（IPv6已经废除了片）***
-	分片的理由：在IPv4的设计中，不同的网络环境可能有不同的MTU，当一个较大的IP数据报传输到一个MTU较小的路由器时，路由器只能将这个较大的数据报分解为多个较小的数据报再传输，而这些较小的报文就称为片。
-	分片的原理：片的组装是在端完成的，路由器只负责分片，而不组装片。
	-	IP数据报中有标识、标志、片偏移，这三个参数来实现分片。
	-	数据报在从源主机发出的时候，每一个IP都有一个标号：标识。对于同一个数据源，源主机每发送一个IP数据报标识都会加一。
	-	当一个数据报被分片时，除最后一个片，其他的片中的标志都是1，最后一个片中的标志是0。
	-	偏移量用来从片重建源IP数据报。通过偏移量可以获得片位于源IP报的位置。

***IPv4编址（ip地址是与接口相关联的）***
-	32位的IP地址，约有40亿个可能的ip地址。
-	点分十进制，192.168.0.0    分别对应一个字节。
-	***编址方案***
	-	分类编址：IP地址的网络部分被确定为8位、16位和24位这三种A、B、C类网址。分类编址的问题在于C类网址中子网可用的IP太少，只有2^8 - 2 = 254台（有两个IP地址有特殊的用途）。B类网址中子网中可用的IP又太多。
	-	以二进制说明 Network 第一个数字的定义：
	```
	Class A : 0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 0
			  |--net--|---------host------------|
	Class B : 10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 10
			  |------net-------|------host------|
	Class C : 110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 110
			  |-----------net-----------|-host--|
	Class D : 1110xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 1110
	Class E : 1111xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==> NetI_D 的开头是 1111
	五种分级在十进制的表示：
	Class A :   0.xx.xx.xx ~ 127.xx.xx.xx
	Class B : 128.xx.xx.xx ~ 191.xx.xx.xx
	Class C : 192.xx.xx.xx ~ 223.xx.xx.xx
	Class D : 224.xx.xx.xx ~ 239.xx.xx.xx
	Class E : 240.xx.xx.xx ~ 255.xx.xx.xx

	上表中你只要记忆三种等级，亦即是 Class A, B, C 即可，因为 Class D 是用来作为群播 (multicast) 的特殊功能之用 (最常用在大批计算机的网络还原)，至于 Class E 则是保留没有使用的网段。
	```
	-	CIDR (classess interdormain routing)   无类别域间选址。即32位IP地址被分为两个部分：a.b.c.d/x  ，x 表示a.b.c.d的前x位为网络前缀。剩余32-x位是用来区分组织内部设备的。            

***DHCP（C/S 协议）***
-	Dynamic Host Configuration Protol  动态主机配置协议（即插即用协议），主机可以使用这个协议自动的获取IP和其他的一些信息。
-	对于一台刚进入一个子网的主机而言，一般需要四个步骤来回去IP地址和一些信息：
	1. 主机使用协议***UDP***向端口 67 发送一条广播报文（DHCP发现报文，目的地址是255.255.255.255，设置源地址是0.0.0.0，端口号设置为67） 
	2. DHCP服务器在收到一个DHCP发现报文后会广播一个DHCP提供报文（因为有可能有多台主机同时请求IP故不能使用目的地址0.0.0.0，要广播）。因为子网中可能有多个DHCP服务器，而且每一个服务器都会在它的DHCP提供报文中提供：发现报文的事务ID，向客户端推荐的IP地址，网络掩码和IP租用期。
	3. 客户机从一个或多个DHCP服务器中选择一个，并用一个DHCP请求报文对选中的服务器进行响应，回显配置参数。
	4. DHCP ACK，DHCP服务器用DHCP ACK 报文对DHCP请求报文进行回响，证实所用参数。
	5. 交互完成。

***网络地址转换（NAT）***
-	Network Address Translation .  
	-	NAT使能路由器对于外界来说相当于一个有单一IP地址的单一设备。路由器与外界相连的IP是公网IP地址，而家庭内部的主机使用的IP都是内网IP，而且内网IP对于外界而言是透明的。
	-	NAT使能路由器会改变由内网发出的经由这个路由器的内网IP数据报中的源IP地址和源端口号。NAT将内网中的IP数据报的源IP改为统一的NAT路由器使用的公网IP，并且将这个数据报的源端口号改为当前NAT转换表中没有使用的一个端口号，并且在这个端口号下记录原来数据报中的端口号，和源IP地址。并将数据发出。
	-	NAT使能路由器在接收到一个IP数据时，会提取这个数据报中的端口号，与NAT维护的NAT转发表进行对照，找到对应的内网IP和端口号，并将IP数据报中的对应字段进行更改，再将数据报发向内网。

-	由上面的NAT原理，我们知道一般而言，内网主机与NAT中的NAT转换表不一定是固定的，故一个TCP连接可能不会持续很久。而TCP是面向连接的，故对于纯TCP程序可能会出问题，虽然有NAT穿越技术，但并不适用所有，不过UPnP可以解决这个问题(P229)。
***ARP&RARP***
-	ARP (Address Resolution Protocol, 网络地址解析) 协议，以及 RARP (Revers ARP, 反向网络地址解析)
> 当我们想要了解某个 IP 其实是设定于某张以太网络卡上头时，我们的主机会对整个区网发送出 ARP 封包， 对方收到 ARP 封包后就会回传他的 MAC 给我们，我们的主机就会知道对方所在的网卡，那接下来就能够开始传递数据啰。当使用 ARP 协议取得目标 IP 与他网卡卡号后， 就会将该笔记录写入我们主机的 ARP table 中 (内存内的数据) 记录 20 分钟。使用指令arp -a 可以在windows下看见与本机同网段的其他主机的MAC地址。ARP 封包取得的 IP/MAC 对应，这个记录的 ARP table 是动态的信息 (一般保留 20 分钟)，他会随时随着你的网域里面计算机的 IP 更动而变化。即 ARP table 会自动的重新对应 IP 与 MAC 的表格内容！但如果你有特殊需求的话， 也可以利用『 arp -s 』这个选项来定义静态的 ARP 对应。

###  在网络上传输的包 [\[Index\]](#Index) <span id="B"/>      

#### MAC包
```
+-----------+-----------------+--------------+-------------------------+--------------+-----------+
| 前导码    | 目的MAC地址     | 源MAC地址    | 资料栅栏...(不懂)       | 主要资料     | 检测码    |
+-----------+-----------------+--------------+-------------------------+--------------+-----------+
| 8bytes    | 6bytes          | 6bytes       | 2bytes                  | 46~1500bytes | 4bytes    |
+-----------+-----------------+--------------+-------------------------+--------------+-----------+
```
从主要资料可以知道标准网络的MTU是1500，但很多比较旧的网络的MTU是1492，而且当网络之间的MTU不同时，较大的数据帧可能会被丢弃，故即使可以更改MTU，也不能随便更改MTU。
-	MAC中的主要资料要大于46bytes是CSMA/CD碰撞检测所需的。
-	MAC包不能跨router。但可以跨第二层交换机。
#### IP包  [\[Index\]](#Index) <span id="IP_package"/>       
```
|<---------------长度为32bit (IP数据包的表头全长一定是32bit的整数倍------>|
+---------------------+----------+-----------------+----------------------+
| Version             | IHL      | Type of Service | Total Length         |
+---------------------+----------+-----------------+----------------------+
|         Identification         | Flags           | Fragmentation Offset |
+---------------------+----------+-----------------+----------------------+
| Time To Live        | Protocol |          Header Checksum               |
+---------------------+----------+-----------------+----------------------+
|                      Source Address                                     |
+---------------------+----------+-----------------+----------------------+
|                      Destination Address                                |
+---------------------+----------+-----------------+----------------------+
|              Options                             | Padding              |
+---------------------+----------+-----------------+----------------------+
|                           Data                                          |
+---------------------+----------+-----------------+----------------------+
```
-	Version(版本)：宣告这个 IP 封包的版本，例如目前惯用的还是 IPv4 这个版本就在这里宣告。
-	IHL(Internet Header Length, IP表头的长度)：告知这个 IP 封包的表头长度，使用的单位应该是字组 (word) ，一个字组为 4bytes 大小喔。
-	Type of Service(服务类型)：这个项目的内容为『PPPDTRUU』，表示这个 IP 封包的服务类型，主要分为：
	-	PPP：表示此 IP 封包的优先度，目前很少使用；
	-	D：若为 0 表示一般延迟(delay)，若为 1 表示为低延迟；
	-	T：若为 0 表示为一般传输量 (throughput)，若为 1 表示为高传输量；
	-	R：若为 0 表示为一般可靠度(reliability)，若为 1 表示高可靠度。
	-	UU：保留尚未被使用。举例来说，gigabit 以太网络的种种相关规格可以让这个 IP 封包加速且降低延迟，某些特殊的标志就是在这里说明的。
-	Total Length(总长度)：指这个 IP 封包的总容量，包括表头与内容 (Data) 部分。最大可达 65535 bytes。
-	Identification(辨别码)：我们前面提到 IP 袋子必须要放在 MAC 袋子当中。不过，如果 IP 袋子太大的话，就得先要将 IP 再重组成较小的袋子然后再放到 MAC 当中。而当 IP 被重组时，每个来自同一个 IP 的小袋子就得要有个标识符以告知接收端这些小袋子其实是来自同一个 IP 封包才行。 也就是说，假如 IP 封包其实是 65536 那么大 (前一个 Total Length 有规定)， 那么这个 IP 就得要再被分成更小的 IP 分段后才能塞进 MAC 讯框中。那么每个小 IP 分段是否来自同一个 IP 资料，呵呵！那就是这个标识符的功用啦！
-	Flags(特殊旗标)：这个地方的内容为『0DM』，其意义为：
	-	D：若为 0 表示可以分段，若为 1 表示不可分段
	-	M：若为 0 表示此 IP 为最后分段，若为 1 表示非最后分段。
-	Fragment Offset(分段偏移)：表示目前这个 IP 分段在原始的 IP 封包中所占的位置。就有点像是序号啦，有这个序号才能将所有的小 IP 分段组合成为原本的 IP 封包大小嘛！透过 Total Length, Identification, Flags 以及这个 Fragment Offset 就能够将小 IP 分段在收受端组合起来啰！
-	Time To Live(TTL, 存活时间)：表示这个 IP 封包的存活时间，范围为 0-255。当这个 IP 封包通过一个路由器时， TTL 就会减一，当 TTL 为 0 时，这个封包将会被直接丢弃。说实在的，要让 IP 封包通过 255 个路由器，还挺难的～ ^_^
-	Protocol Number(协定代码)：来自传输层与网络层本身的其他数据都是放置在 IP 封包当中的，我们可以在 IP 表头记载这个 IP 封包内的资料是啥， 在这个字段就是记载每种数据封包的内容啦！在这个字段记载的代码与相关的封包协议名称如下所示：
```
+-------------+-------------------------------------------+
| IP内号码    | 协议                                      |
+-------------+-------------------------------------------+
| 1           | ICMP (Internet Control Message Protocol)  |
+-------------+-------------------------------------------+
| 2           | IGMP (Internet Group Management Protocol) |
+-------------+-------------------------------------------+
| 3           | GGP (Gateway-to-Gateway Protocol)         |
+-------------+-------------------------------------------+
| 4           | IP (IP in IP encapsulation)               |
+-------------+-------------------------------------------+
| 6           | TCP (Transmission Control Protocol)       |
+-------------+-------------------------------------------+
| 8           | EGP (Exterior Gateway Protocol)           |
+-------------+-------------------------------------------+
| 17          | UDP (User Datagram Protocol)              |
+-------------+-------------------------------------------+
```
-	Header Checksum(表头检查码)：用来检查这个 IP 表头的错误检验之用。
-	Source Address：
-	Destination Address
-	Options (其他参数)：这个是额外的功能，提供包括安全处理机制、路由纪录、时间戳、严格与宽松之来源路由等。
-	Padding(补齐项目)：由于 Options 的内容不一定有多大，但是我们知道 IP 每个数据都必须要是 32 bits，所以，若 Options 的数据不足 32 bits 时，则由 padding 主动补齐。
